/**
 * Implementation of LUD-03: withdrawRequest base specification
 * @see https://github.com/lnurl/luds/blob/luds/03.md
 *
 * Wallet to service interaction flow:
 * 1. User scans LNURL QR code or accesses lightning:LNURL link
 * 2. LN WALLET makes GET request to LN SERVICE using decoded LNURL
 * 3. LN SERVICE returns withdrawRequest data (callback URL, k1, amounts)
 * 4. LN WALLET displays withdraw dialog with bounded amount selection
 * 5. User confirms amount, LN WALLET generates invoice and calls callback
 * 6. LN SERVICE pays invoice and returns success/error response
 * 7. LN WALLET awaits payment if response was successful
 */

/**
 * Creates a withdraw request response object as per LUD-03 spec
 * @param {string} callback - URL where LN SERVICE accepts withdrawal Lightning invoice
 * @param {string} k1 - Random string to identify user's LN WALLET
 * @param {string} defaultDescription - Default withdrawal invoice description
 * @param {number} minWithdrawable - Minimum withdrawable amount in millisatoshis
 * @param {number} maxWithdrawable - Maximum withdrawable amount in millisatoshis
 * @returns {{tag: string, callback: string, k1: string, defaultDescription: string, minWithdrawable: number, maxWithdrawable: number} | {status: string, reason: string}}
 */
export const createWithdrawRequest = (
  callback,
  k1,
  defaultDescription,
  minWithdrawable,
  maxWithdrawable,
) => {
  try {
    // Input validation
    if (typeof callback !== "string") {
      return {
        status: "ERROR",
        reason: "Invalid callback URL: Must be a string",
      };
    }

    try {
      const url = new URL(callback);
      if (
        !(url.protocol === "https:" && !url.hostname.endsWith(".onion")) &&
        !(url.protocol === "http:" && url.hostname.endsWith(".onion"))
      ) {
        return {
          status: "ERROR",
          reason:
            "Invalid callback URL: Must be HTTPS clearnet or HTTP onion service",
        };
      }
    } catch (error) {
      return {
        status: "ERROR",
        reason: "Invalid callback URL: Must be a valid HTTP(S) URL",
      };
    }

    if (typeof k1 !== "string" || k1.trim().length === 0) {
      return {
        status: "ERROR",
        reason: "Invalid k1: Must be a non-empty string",
      };
    }

    if (typeof defaultDescription !== "string") {
      return {
        status: "ERROR",
        reason: "Invalid defaultDescription: Must be a string",
      };
    }

    if (!Number.isInteger(minWithdrawable) || minWithdrawable < 0) {
      return {
        status: "ERROR",
        reason: "Invalid minWithdrawable: Must be a non-negative integer",
      };
    }

    if (
      !Number.isInteger(maxWithdrawable) ||
      maxWithdrawable < minWithdrawable
    ) {
      return {
        status: "ERROR",
        reason: "Invalid maxWithdrawable: Must be >= minWithdrawable",
      };
    }

    return {
      tag: "withdrawRequest",
      callback,
      k1,
      defaultDescription,
      minWithdrawable,
      maxWithdrawable,
    };
  } catch (error) {
    return {
      status: "ERROR",
      reason: error.message,
    };
  }
};

/**
 * Generates the callback URL for a withdrawal request
 * @param {string} callback - Base callback URL from withdrawRequest
 * @param {string} k1 - The k1 parameter from withdrawRequest
 * @param {string} paymentRequest - BOLT-11 invoice generated by the wallet
 * @returns {{url: string} | {status: string, reason: string}}
 */
export const generateWithdrawCallbackUrl = (callback, k1, paymentRequest) => {
  try {
    if (!callback || !k1 || !paymentRequest) {
      return {
        status: "ERROR",
        reason: "Missing required parameters: callback, k1, or paymentRequest",
      };
    }

    const url = new URL(callback);
    const separator = url.search ? "&" : "?";

    return {
      url: `${callback}${separator}k1=${encodeURIComponent(k1)}&pr=${encodeURIComponent(paymentRequest)}`,
    };
  } catch (error) {
    return {
      status: "ERROR",
      reason: `Invalid URL or parameters: ${error.message}`,
    };
  }
};

/**
 * Validates if a withdrawal amount is within the allowed bounds
 * @param {number} amount - Amount to validate in millisatoshis
 * @param {number} minWithdrawable - Minimum allowed withdrawal amount
 * @param {number} maxWithdrawable - Maximum allowed withdrawal amount
 * @param {number} [maxRoutable] - Optional local estimation of maximum routable amount
 * @returns {{isValid: boolean, effectiveMin: number, effectiveMax: number, reason?: string}}
 */
export const validateWithdrawAmount = (
  amount,
  minWithdrawable,
  maxWithdrawable,
  maxRoutable,
) => {
  // Calculate effective bounds
  const effectiveMax = maxRoutable
    ? Math.min(maxWithdrawable, maxRoutable)
    : maxWithdrawable;
  const effectiveMin = minWithdrawable;

  if (!Number.isInteger(amount)) {
    return {
      isValid: false,
      effectiveMin,
      effectiveMax,
      reason: "Amount must be an integer",
    };
  }

  if (amount < effectiveMin) {
    return {
      isValid: false,
      effectiveMin,
      effectiveMax,
      reason: `Amount below minimum: ${effectiveMin} msats`,
    };
  }

  if (amount > effectiveMax) {
    return {
      isValid: false,
      effectiveMin,
      effectiveMax,
      reason: `Amount above maximum: ${effectiveMax} msats`,
    };
  }

  return {
    isValid: true,
    effectiveMin,
    effectiveMax,
  };
};

/**
 * Creates a success response
 * @returns {{status: string}}
 */
export const createSuccessResponse = () => ({
  status: "OK",
});

/**
 * Creates an error response
 * @param {string} reason - The error reason
 * @returns {{status: string, reason: string}}
 */
export const createErrorResponse = (reason) => ({
  status: "ERROR",
  reason,
});

export default {
  createWithdrawRequest,
  generateWithdrawCallbackUrl,
  validateWithdrawAmount,
  createSuccessResponse,
  createErrorResponse,
};
